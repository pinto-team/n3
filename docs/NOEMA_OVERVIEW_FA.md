# معرفی مغز Noema

## چرا این سند مهم است؟
این سند تصویری جامع از «مغز» سامانهٔ Noema ارائه می‌کند تا اعضای تیم بدانند موتور اصلی گفتگو و اجرا از چه اجزایی تشکیل شده، هر لایه چه مسئولیتی دارد و خروجی هر بخش چگونه در تصمیم‌گیری‌های نهایی اثر می‌گذارد. معماری Noema بر پایهٔ یک هستهٔ ترتیبی ساخته شده که بلوک‌های تخصصی را به‌صورت ایمن و قابل ترکیب کنار هم قرار می‌دهد.

## معماری کلی
- **هستهٔ ترتیبی (B0F1)**: تابع `b0f1_kernel_step` وضعیت ورودی را می‌گیرد، مجموعهٔ بلوک‌های فعال را مطابق ترتیب پیش‌فرض اجرا می‌کند و خروجی هر بلوک را به‌صورت عمیق در وضعیت مشترک ادغام می‌کند. شکست یک بلوک سایر مراحل را متوقف نمی‌کند و گزارش تفصیلی از مراحل اجراشده، رد شده و خطا داده می‌شود.【F:n3_core/kernel/b0f1_noema_kernel_step.py†L44-L110】
- **قرارداد دادهٔ PackZ**: بلوک ادراک ۱۰ (`b1f10_packz`) تمام سیگنال‌های برداشت‌شده از متن (نرمال‌سازی، نشانه‌گذاری جملات، تشخیص جهت متن، عمل گفتاری و غیره) را در یک بستهٔ پایدار با شناسهٔ SHA1، شمارش‌ها، سیگنال‌ها و متادیتا آماده می‌کند. این بسته بنیان اشتراک داده میان تمام بلوک‌هاست.【F:n3_core/block_1_perception/b1f10_packz.py†L15-L215】

## بلوک‌های کارکردی
### 1. ادراک (Perception)
- جمع‌آوری رویدادهای تایپ و پیام، استخراج آخرین پیام معتبر و تولید متای اولیه بدون تغییر متن خام.【F:n3_core/block_1_perception/b1f1_collector.py†L40-L88】
- نرمال‌سازی متن با حذف کاراکترهای صفرعرض (به‌جز نیم‌فاصله)، یکسان‌سازی یونیکد، حذف کنترل‌های نامجاز و برش ایمن برای جلوگیری از ورودی‌های طولانی.【F:n3_core/block_1_perception/b1f2_normalizer.py†L12-L155】
- تشخیص این‌که پیام واقعاً خطاب به Noema است یا خیر؛ با پشتیبانی از نام‌های چندزبانه، منشن‌ها و تحلیل عبارات خطاب در ابتدای جمله.【F:n3_core/block_1_perception/b1f6_addressing.py†L13-L205】
- بسته‌بندی نهایی PackZ شامل متن نرمال‌شده، آمار واژگان، برچسب‌های اسکریپت و سیگنال‌های ادراکی (جهت متن، اعتماد، نوآوری، نوع گفتار).【F:n3_core/block_1_perception/b1f10_packz.py†L136-L215】

### 2. مدل جهان (World Model)
- ساخت زمینهٔ ساخت‌یافته از پیام جاری و حافظهٔ نزدیک: محاسبهٔ ویژگی‌هایی مانند طول، شباهت با پیام‌های اخیر، اطمینان و نوآوری برای تغذیهٔ پیش‌بینی‌ها.【F:n3_core/block_2_world_model/b2f1_context_builder.py†L147-L220】
- پیش‌بینی سبک پاسخ بعدی (پاسخ مستقیم، اقدام، سؤال clarifying و...) با استفاده از قواعد اکتشافی روی ویژگی‌های زمینه و استخراج راهنمایی برای گیت بعدی و نیاز به جمع‌آوری اسلات‌ها.【F:n3_core/block_2_world_model/b2f2_predictor.py†L137-L236】

### 3. حافظه (Memory)
- بازیابی درون‌حافظه‌ای بر اساس n-gram کاراکتری، شباهت واژگانی، امتیاز تازگی و فاست‌های هماهنگ (جهت متن، نوع گفتار) با در نظر گرفتن مزیت زمانی برای مثال‌های تازه.【F:n3_core/block_3_memory/b3f3_retriever.py†L16-L256】

### 4. گراف مفهومی (Concept Graph)
- استخراج اصطلاحات پرتکرار، n-gramهای معنادار و لبه‌های هم‌رخدادی با محاسبهٔ PMI از بدنه‌ای کوچک شامل پیام فعلی و نمونه‌های حافظه برای پشتیبانی از کشف الگو و دانش درون‌گفتگو.【F:n3_core/block_4_concept_graph/b4f1_pattern_miner.py†L17-L259】

### 5. برنامه‌ریزی (Planning)
- ترکیب قصد تشخیص‌داده‌شده، اسلات‌های پر/خالی، عدم‌قطعیت مدل جهان و برآورد نوع پاسخ برای ساخت پلنی دارای شناسهٔ پایدار، گام‌های پرسش از کاربر، تأیید، اجرای مهارت یا پاسخ مستقیم و گاردریل‌های تأیید اجباری.【F:n3_core/block_5_planning/b5f3_plan_builder.py†L108-L228】

### 6. دیالوگ (Dialog)
- نگاشت گام منطقی (ask/confirm/answer/ack/refuse/execute) به متن خروجی سطحی با انتخاب زبان بر اساس جهت متن، قالب‌بندی بولت‌ها و کنترل طول؛ همچنین نگهداری سبک شخصیتی سازگار.【F:n3_core/block_6_dialog/b6f2_surface_nlg.py†L117-L170】

### 7. اجرا (Execution)
- تجمیع عملیات اجرای مهارت از پلن یا گام گفتگویی، اعمال گاردهای تأیید، ساخت درخواست‌های idempotent با محدودیت‌های زمان و تلاش مجدد برای ارسال به لایهٔ مهارت‌ها.【F:n3_core/block_7_execution/b7f1_skill_dispatcher.py†L32-L147】

### 8. ماندگاری (Persistence)
- تولید عملیات WAL خالص برای ذخیرهٔ نوبت کاربر و دستیار، پیوند نتیجهٔ اجرا به نوبت دستیار و به‌روزرسانی شمارنده‌ها؛ با تولید شناسه‌های پایدار و بسته‌های PackZ برای هر نوبت.【F:n3_core/block_8_persistence/b8f1_memory_commit.py†L122-L227】

### 9. مشاهده‌پذیری (Observability)
- بازسازی رد اجرایی یک گردش (spans و timeline) از اطلاعات طرح، اجرا، گفتگو و اعمال ذخیره‌سازی جهت پایش SLO و رفع اشکال.【F:n3_core/block_9_observability/b9f2_trace_builder.py†L140-L240】

### 10. سازگارپذیری (Adaptation)
- اعتبارسنجی دلتای سیاست، محدود کردن تعداد تغییرها، تولید عملیات `set` و پیش‌نمایش پیکربندی جدید همراه با فهرست تغییرات پذیرفته/رد شده برای اجرای ایمن آزمایش‌ها.【F:n3_core/block_10_adaptation/b10f2_policy_apply_planner.py†L90-L205】

### 11. زمان اجرا (Runtime)
- اعمال گیت‌های اجرایی بر اساس امتیاز SLO، عدم‌قطعیت، تأخیر اجرا و اندازهٔ صف ایندکس؛ فعال‌سازی فلگ‌های فیچری با rollout درصدی و تولید دلایل تصمیم‌گیری برای شفافیت.【F:n3_core/block_11_runtime/b11f2_runtime_gatekeeper.py†L36-L205】

### 12. ارکستراسیون (Orchestration)
- ترکیب تصمیمات زمان اجرا با وضعیت گفتگو برای تولید فهرست اقدامات موتور (delay، emit، execute، persist یا noop) و تعیین پایان تیک فعلی در صورت ارسال پاسخ یا اجرای مهارت.【F:n3_core/block_12_orchestration/b12f1_orchestrator_tick.py†L51-L162】

### 13. درایورها (Drivers)
- تبدیل «jobs» انتزاعی به فریم‌های قابل مصرف برای ترنسپورت، مهارت‌ها، ذخیره‌سازی و تایمر، همراه با برش متن، محدودیت اندازهٔ دسته و تنظیم endpoints سفارشی.【F:n3_core/block_13_drivers/b13f1_driver_protocol_builder.py†L48-L205】

## چرخهٔ اجرای یک تیک
۱. پیام جدید وارد ادراک شده و PackZ ساخته می‌شود.
۲. مدل جهان زمینه را به‌روزرسانی کرده و پیش‌بینی راهبرد پاسخ را ارائه می‌کند.
۳. حافظه و گراف مفهومی مواد لازم برای برنامه‌ریزی را می‌دهند، سپس پلن و گام گفتگویی شکل می‌گیرد.
۴. متن خروجی و درخواست‌های اجرا ساخته شده، پس از عبور از گیت زمان اجرا و اورکستراتور به درایورها می‌رسند.
۵. نتیجهٔ اجرا و پاسخ در حافظه ذخیره می‌شود و در همان چرخه، رد مشاهده‌پذیری ایجاد می‌گردد.
این توالی به‌صورت خودکار توسط هستهٔ B0F1 و ترتیب پیش‌فرض مراحل مدیریت می‌شود.【F:n3_core/kernel/b0f1_noema_kernel_step.py†L44-L110】

## رابط‌های بیرونی
لایهٔ API با FastAPI پیاده شده و روت‌های اصلی (سیاست، دانش، مهارت، چت، ابتکار، وب‌سوکت و رابط کاربری) در `http_app.py` رجیستر شده‌اند؛ نقطهٔ سلامت `/health` برای پایش ساده در نظر گرفته شده است.【F:n3_api/http_app.py†L3-L28】

## قابلیت‌های کلیدی در یک نگاه
- پردازش دو سویهٔ فارسی/انگلیسی با تشخیص اسکریپت، جهت متن و آدرس‌دهی دقیق.【F:n3_core/block_1_perception/b1f6_addressing.py†L13-L205】【F:n3_core/block_1_perception/b1f10_packz.py†L136-L210】
- برنامه‌ریزی قابل توضیح با شناسهٔ پایدار، گاردریل تأیید، خلاصهٔ خشکی (dry run) و قدم‌های قابل بازنگری.【F:n3_core/block_5_planning/b5f3_plan_builder.py†L108-L224】
- سازوکار اجرای ایمن شامل گیت‌های مبتنی بر SLO، نرخ‌بندی تأخیری و صف ایندکس، به‌همراه فریم‌های درایور idempotent برای ارسال به سامانه‌های بیرونی.【F:n3_core/block_11_runtime/b11f2_runtime_gatekeeper.py†L134-L205】【F:n3_core/block_13_drivers/b13f1_driver_protocol_builder.py†L140-L205】
- مشاهده‌پذیری تعبیه‌شده با تولید span و timeline برای هر تیک، مناسب مانیتورینگ و تحلیل علت مشکل.【F:n3_core/block_9_observability/b9f2_trace_builder.py†L140-L240】
- حافظهٔ ساخت‌یافته و قابل بازیابی برای پاسخ‌های زمینه‌مند و تشکیل گراف مفهومی پویا از مکالمه.【F:n3_core/block_3_memory/b3f3_retriever.py†L218-L246】【F:n3_core/block_4_concept_graph/b4f1_pattern_miner.py†L246-L259】

این معماری ماژولار امکان می‌دهد هر بلوک به‌صورت مستقل توسعه و آزمایش شود و در عین حال، خروجی یک چرخهٔ گفتگویی منسجم، قابل کنترل و قابل مشاهده باقی بماند.
