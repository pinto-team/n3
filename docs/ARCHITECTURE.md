# Noema Architecture

Noema is organised as a pure-functional reasoning pipeline where each block consumes a shared
`state` dictionary and returns a partial update. The kernel composes these blocks deterministically
so that cognition can be replayed and audited.

## Core Flow

1. **Perception (B1)** normalises incoming user turns into PackZ envelopes.
2. **World Model (B2)** predicts conversational moves and now records reward-rich traces that drive
   the adaptation loop.
3. **Memory (B3)** weights long-term recall by recency, relevance, and semantic cosine features.
4. **Concept Graph (B4)** mines terms, promotes them to canonical nodes, scores edges, and extracts
   rules. Each mining pass emits a versioned concept snapshot used for persistence and reflection.
5. **Planning / Dialog / Execution (B5–B7)** construct moves, render natural language, and dispatch
   skills.
6. **Persistence (B8)** stages WAL commits and now journals concept graph versions for rollback.
7. **Observability (B9)** aggregates metrics including uncertainty, reward trends, policy update
   counts, and concept growth signals.
8. **Adaptation (B10)** blends reward traces into policy weights and publishes learning summaries.
9. **Runtime / Orchestration / Drivers (B11–B13)** activate configs, schedule initiative, package
   driver jobs, and surface transport events.

All blocks remain pure: they operate on a deep copy of `state` and never perform I/O. Persistence and
networking are delegated to drivers in B13 and to the runtime adapters.

## Key Data Contracts

- `state.policy.learning`: policy weights, version metadata, and rollback snapshot generated by
  B10F1. The reinforcement learner stores deltas here so later ticks can resume training safely.
- `state.concept_graph.version`: version identifier for the current concept graph along with counts
  of rules, edges, and nodes. B8F1 reads this to journal concept evolution.
- `state.observability.telemetry.summary`: compact metrics used by initiative scheduling, the REST
  `/health` endpoint, and the dashboard.

The adapters registry (`n3_runtime.adapters.registry`) binds blocks lazily so development sessions
can opt into concept graph mining, telemetry, or persistence without modifying the kernel.
